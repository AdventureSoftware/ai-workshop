/**
 * R.E.D. Verification Checklist Examples
 *
 * This file demonstrates how to verify AI-generated code using:
 * - Read: Code review questions
 * - Execute: Test-driven verification
 * - Diff-review: Compare against mental model
 */

import { ValidationResult } from '../types/auth';

// EXAMPLE: AI-GENERATED CODE TO VERIFY
// Let's say Copilot generated this function - apply R.E.D. checklist

/**
 * Validates email format and returns normalized email
 * Generated by AI - needs R.E.D. verification
 */
function validateEmailAI(email: string): ValidationResult<string> {
  // This is AI-generated code that needs verification
  if (!email) {
    return { success: false, error: 'Email is required' };
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return { success: false, error: 'Invalid email format' };
  }

  return {
    success: true,
    data: email.toLowerCase().trim()
  };
}

// R.E.D. VERIFICATION CHECKLIST APPLICATION

/**
 * READ - Code Review Questions:
 * ✅ Does this solve the actual problem I described?
 * ✅ Are variable names consistent with our codebase?
 * ❓ Any magic numbers or hardcoded values that should be constants?
 * ❓ Does error handling match our team patterns?
 * ✅ Are there any TODO comments or incomplete sections?
 *
 * FINDINGS:
 * - Email regex might be too simple for edge cases
 * - Should validate email length limits per RFC 5322
 * - Missing rate limiting for validation attempts
 */

/**
 * EXECUTE - Test the generated code
 * Write comprehensive tests to verify AI behavior
 */

// Test cases for verification
const testCases = [
  // Happy path
  { input: 'user@example.com', expected: { success: true, data: 'user@example.com' } },

  // Edge cases AI might miss
  { input: 'user+tag@example.co.uk', expected: { success: true, data: 'user+tag@example.co.uk' } },
  { input: 'a'.repeat(64) + '@example.com', expected: { success: false } }, // Too long local part
  { input: 'user@' + 'a'.repeat(250) + '.com', expected: { success: false } }, // Too long domain

  // Security edge cases
  { input: 'user@example.com\n', expected: { success: true, data: 'user@example.com' } }, // Newline injection
  { input: '  USER@EXAMPLE.COM  ', expected: { success: true, data: 'user@example.com' } }, // Case/whitespace
];

/**
 * DIFF-REVIEW - Compare against mental model
 *
 * Mental model expectations:
 * 1. Should handle international domains (✅ basic regex does)
 * 2. Should normalize case and whitespace (✅ implemented)
 * 3. Should validate length limits (❌ missing)
 * 4. Should handle plus addressing (✅ regex allows)
 * 5. Should prevent injection attacks (⚠️ partially - trims but doesn't sanitize)
 *
 * GAPS IDENTIFIED:
 * - Missing RFC 5322 length validation
 * - No input sanitization beyond trim
 * - Regex could be more robust
 */

// IMPROVED VERSION AFTER R.E.D. VERIFICATION
/**
 * Enhanced email validator based on R.E.D. findings
 * Addresses gaps found in AI-generated version
 */
function validateEmailImproved(email: string): ValidationResult<string> {
  // Input sanitization
  if (typeof email !== 'string') {
    return { success: false, error: 'Email must be a string' };
  }

  const trimmed = email.trim();

  // Length validation per RFC 5322
  if (trimmed.length === 0) {
    return { success: false, error: 'Email is required' };
  }

  if (trimmed.length > 254) {
    return { success: false, error: 'Email too long (max 254 characters)' };
  }

  // More robust email regex
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

  if (!emailRegex.test(trimmed)) {
    return { success: false, error: 'Invalid email format' };
  }

  // Check local part length (before @)
  const [localPart] = trimmed.split('@');
  if (localPart.length > 64) {
    return { success: false, error: 'Email local part too long (max 64 characters)' };
  }

  return {
    success: true,
    data: trimmed.toLowerCase()
  };
}

// COMMON AI CODE FAILURE PATTERNS TO WATCH FOR

/**
 * Pattern 1: Wrong API Usage
 * AI might suggest outdated or non-existent methods
 */
function checkForWrongApiUsage() {
  // ❌ AI might suggest non-existent methods
  // JSON.parseAsync() // This doesn't exist

  // ✅ Verify against official docs
  // JSON.parse() // This is correct
}

/**
 * Pattern 2: Logic Errors
 * AI follows patterns but misses business rules
 */
function checkBusinessLogic(age: number): boolean {
  // ❌ AI might generate generic validation
  // return age > 0; // Misses business rule about minimum age

  // ✅ After R.E.D. review: include business context
  return age >= 13; // COPPA compliance requires minimum age 13
}

/**
 * Pattern 3: Performance Issues
 * AI optimizes for readability, not performance
 */
function checkPerformance(items: string[]): string[] {
  // ❌ AI might generate inefficient code
  // return items.filter(item => item.length > 0).map(item => item.toUpperCase());

  // ✅ After performance review: optimize
  const result: string[] = [];
  for (const item of items) {
    if (item.length > 0) {
      result.push(item.toUpperCase());
    }
  }
  return result;
}

// DEBUGGING STRATEGY FOR FAILED AI PROMPTS
/**
 * When AI suggestions fail, follow this debug process:
 * 1. Isolate the AI-generated portion
 * 2. Add logging/breakpoints to see actual vs expected behavior
 * 3. Compare with working examples in codebase
 * 4. Refine prompt with concrete examples
 */

export {
  validateEmailAI,
  validateEmailImproved,
  checkForWrongApiUsage,
  checkBusinessLogic,
  checkPerformance,
  testCases
};
