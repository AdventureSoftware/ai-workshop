using AIPairProgramming.Shared.Models;

namespace AIPairProgramming.Examples;

/// <summary>
/// R.E.D. Verification Checklist Examples
/// 
/// This file demonstrates how to verify AI-generated code using:
/// - Read: Code review questions
/// - Execute: Test-driven verification
/// - Diff-review: Compare against mental model
/// </summary>
public class VerificationRedChecklist
{
    // EXAMPLE: AI-GENERATED CODE TO VERIFY
    // Let's say Copilot generated this function - apply R.E.D. checklist

    /// <summary>
    /// Validates email format and returns normalized email
    /// Generated by AI - needs R.E.D. verification
    /// </summary>
    public ValidationResult<string> ValidateEmailAI(string email)
    {
        // This is AI-generated code that needs verification
        if (string.IsNullOrEmpty(email))
        {
            return ValidationResult<string>.FailureResult("Email is required");
        }

        var emailRegex = new System.Text.RegularExpressions.Regex(@"^[^\s@]+@[^\s@]+\.[^\s@]+$");
        if (!emailRegex.IsMatch(email))
        {
            return ValidationResult<string>.FailureResult("Invalid email format");
        }

        return ValidationResult<string>.SuccessResult(email.ToLower().Trim());
    }

    // R.E.D. VERIFICATION CHECKLIST APPLICATION

    /*
     * READ - Code Review Questions:
     * ✅ Does this solve the actual problem I described?
     * ✅ Are variable names consistent with our codebase?
     * ❓ Any magic numbers or hardcoded values that should be constants?
     * ❓ Does error handling match our team patterns?
     * ✅ Are there any TODO comments or incomplete sections?
     *
     * FINDINGS:
     * - Email regex might be too simple for edge cases
     * - Should validate email length limits per RFC 5322
     * - Missing rate limiting for validation attempts
     */

    /*
     * EXECUTE - Test the generated code
     * Write comprehensive tests to verify AI behavior
     */

    // Test cases for verification
    private static readonly (string Input, bool ShouldSucceed, string? ExpectedData)[] TestCases = 
    [
        // Happy path
        ("user@example.com", true, "user@example.com"),
        
        // Edge cases AI might miss
        ("user+tag@example.co.uk", true, "user+tag@example.co.uk"),
        (new string('a', 64) + "@example.com", false, null), // Too long local part
        ("user@" + new string('a', 250) + ".com", false, null), // Too long domain
        
        // Security edge cases
        ("user@example.com\n", true, "user@example.com"), // Newline injection
        ("  USER@EXAMPLE.COM  ", true, "user@example.com") // Case/whitespace
    ];

    /*
     * DIFF-REVIEW - Compare against mental model
     *
     * Mental model expectations:
     * 1. Should handle international domains (✅ basic regex does)
     * 2. Should normalize case and whitespace (✅ implemented)
     * 3. Should validate length limits (❌ missing)
     * 4. Should handle plus addressing (✅ regex allows)
     * 5. Should prevent injection attacks (⚠️ partially - trims but doesn't sanitize)
     *
     * GAPS IDENTIFIED:
     * - Missing RFC 5322 length validation
     * - No input sanitization beyond trim
     * - Regex could be more robust
     */

    // IMPROVED VERSION AFTER R.E.D. VERIFICATION
    /// <summary>
    /// Enhanced email validator based on R.E.D. findings
    /// Addresses gaps found in AI-generated version
    /// </summary>
    public ValidationResult<string> ValidateEmailImproved(string email)
    {
        // Input sanitization
        if (email is null)
        {
            return ValidationResult<string>.FailureResult("Email must not be null");
        }

        var trimmed = email.Trim();

        // Length validation per RFC 5322
        if (trimmed.Length == 0)
        {
            return ValidationResult<string>.FailureResult("Email is required");
        }

        if (trimmed.Length > 254)
        {
            return ValidationResult<string>.FailureResult("Email too long (max 254 characters)");
        }

        // More robust email regex
        var emailRegex = new System.Text.RegularExpressions.Regex(
            @"^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$");

        if (!emailRegex.IsMatch(trimmed))
        {
            return ValidationResult<string>.FailureResult("Invalid email format");
        }

        // Check local part length (before @)
        var localPart = trimmed.Split('@')[0];
        if (localPart.Length > 64)
        {
            return ValidationResult<string>.FailureResult("Email local part too long (max 64 characters)");
        }

        return ValidationResult<string>.SuccessResult(trimmed.ToLower());
    }

    // COMMON AI CODE FAILURE PATTERNS TO WATCH FOR

    /// <summary>
    /// Pattern 1: Wrong API Usage
    /// AI might suggest outdated or non-existent methods
    /// </summary>
    public void CheckForWrongApiUsage()
    {
        // ❌ AI might suggest non-existent methods
        // await Json.ParseAsync(); // This doesn't exist in .NET

        // ✅ Verify against official docs
        // JsonSerializer.Deserialize<T>(); // This is correct
    }

    /// <summary>
    /// Pattern 2: Logic Errors
    /// AI follows patterns but misses business rules
    /// </summary>
    public bool CheckBusinessLogic(int age)
    {
        // ❌ AI might generate generic validation
        // return age > 0; // Misses business rule about minimum age

        // ✅ After R.E.D. review: include business context
        return age >= 13; // COPPA compliance requires minimum age 13
    }

    /// <summary>
    /// Pattern 3: Performance Issues
    /// AI optimizes for readability, not performance
    /// </summary>
    public string[] CheckPerformance(string[] items)
    {
        // ❌ AI might generate inefficient code
        // return items.Where(item => !string.IsNullOrEmpty(item)).Select(item => item.ToUpper()).ToArray();

        // ✅ After performance review: optimize for large collections
        var result = new List<string>(items.Length);
        foreach (var item in items)
        {
            if (!string.IsNullOrEmpty(item))
            {
                result.Add(item.ToUpper());
            }
        }
        return result.ToArray();
    }

    /// <summary>
    /// Pattern 4: Exception Handling Issues
    /// AI might not follow .NET exception conventions
    /// </summary>
    public ValidationResult<decimal> SafeDivision(decimal dividend, decimal divisor)
    {
        // ✅ Good: Return result pattern instead of throwing
        if (divisor == 0)
        {
            return ValidationResult<decimal>.FailureResult("Cannot divide by zero");
        }

        return ValidationResult<decimal>.SuccessResult(dividend / divisor);
    }

    // DEBUGGING STRATEGY FOR FAILED AI PROMPTS
    /*
     * When AI suggestions fail, follow this debug process:
     * 1. Isolate the AI-generated portion
     * 2. Add logging/debugging to see actual vs expected behavior  
     * 3. Compare with working examples in codebase
     * 4. Refine prompt with concrete examples
     */

    /// <summary>
    /// Example of iterative prompt refinement
    /// Shows how to improve AI suggestions through better prompting
    /// </summary>
    public class PromptIterationExample
    {
        // ❌ First try: "Validate user input"
        public bool ValidateInputV1(string input)
        {
            return !string.IsNullOrEmpty(input);
        }

        // ❌ Second try: "Validate user input with error handling"
        public ValidationResult<string> ValidateInputV2(string input)
        {
            if (string.IsNullOrEmpty(input))
                return ValidationResult<string>.FailureResult("Input required");
            
            return ValidationResult<string>.SuccessResult(input);
        }

        // ✅ Third try: Concrete specification
        // "Validate user registration form input:
        // - Name: 2-100 characters, letters and spaces only
        // - Email: RFC 5322 format, max 254 chars
        // - Password: 12+ chars, uppercase, lowercase, number, symbol
        // Return: ValidationResult<T> with specific error messages"
        public ValidationResult<UserRegistration> ValidateRegistrationInput(string name, string email, string password)
        {
            var errors = new List<ValidationError>();

            // Name validation
            if (string.IsNullOrWhiteSpace(name))
                errors.Add(new ValidationError(nameof(name), "REQUIRED", "Name is required"));
            else if (name.Length < 2 || name.Length > 100)
                errors.Add(new ValidationError(nameof(name), "LENGTH", "Name must be 2-100 characters"));
            else if (!System.Text.RegularExpressions.Regex.IsMatch(name, @"^[a-zA-Z\s]+$"))
                errors.Add(new ValidationError(nameof(name), "FORMAT", "Name can only contain letters and spaces"));

            // Email validation using improved method
            var emailResult = ValidateEmailImproved(email);
            if (!emailResult.Success)
                errors.Add(new ValidationError(nameof(email), "INVALID", emailResult.Error ?? "Invalid email"));

            // Password validation
            var passwordErrors = ValidatePasswordStrength(password);
            errors.AddRange(passwordErrors);

            if (errors.Count > 0)
                return ValidationResult<UserRegistration>.FailureResult(errors);

            return ValidationResult<UserRegistration>.SuccessResult(new UserRegistration(email, name, password));
        }

        private List<ValidationError> ValidatePasswordStrength(string password)
        {
            var errors = new List<ValidationError>();
            
            if (string.IsNullOrEmpty(password))
                errors.Add(new ValidationError("password", "REQUIRED", "Password is required"));
            else
            {
                if (password.Length < 12)
                    errors.Add(new ValidationError("password", "TOO_SHORT", "Password must be at least 12 characters"));
                
                if (!password.Any(char.IsUpper))
                    errors.Add(new ValidationError("password", "NO_UPPERCASE", "Password must contain uppercase letter"));
                
                if (!password.Any(char.IsLower))
                    errors.Add(new ValidationError("password", "NO_LOWERCASE", "Password must contain lowercase letter"));
                
                if (!password.Any(char.IsDigit))
                    errors.Add(new ValidationError("password", "NO_DIGIT", "Password must contain number"));
                
                if (!password.Any(ch => !char.IsLetterOrDigit(ch)))
                    errors.Add(new ValidationError("password", "NO_SYMBOL", "Password must contain special character"));
            }
            
            return errors;
        }
    }
}